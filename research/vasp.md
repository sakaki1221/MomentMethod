# vaspを組み込む
ポテンシャルをeVで扱えるように修正する．
## まずは単位確認
もともと
* ポテンシャル
  * kelvin
* ボルツマン定数
  * BOLTZ = 1.38064852e-16
  * $1.38064852×10^{−23} J/K$
* プランク定数
  * PLANCK = 6.626e-27
  * $6.62607004 × 10^{-34} Js$
* アボガドロ定数
  * AVOGADO = 6.023e23
  * $6.022140857×10^{23} 1/mol$

# 進捗
* 元のポテンシャルをJに変換
4125.70*1.38064852e-16に
* 距離をangstromにする．
エラーですすまないので直接evで作ることにするvasptest_ev
#
e-6で試すと回った．　e-10だとNaNを出力してループが上手く回らないのが原因だと思われる(xの計算の際にtanhがNaN，e**750ぐらいからinfinityになってる)．

元のポテンシャルはKでありボルツマン定数を-23でかけると
プランク数，ボルツマン共に元の定数で上手く回る．
とりあえずJでの計算は完成
eVに移項のテストを行う．

#原子間距離の単位を変えることの影響
1e-8から1に変更
a1, same,changeとkのそれぞれの４つの項とkの比較
1の結果
```
a1, same, change
"2.512666221358055, 1, 1"
k
1.106984860823601e-18
-2.820551839851343e-20
-3.4616194218706006e-20
1.4102759199256576e-20
1.058265907405638e-18
a1, same, change
"2.5226662213580546, 2, 1"
k
1.0356213396127194e-18
-1.960302143675833e-20
-3.4029695402356626e-20
1.3774739097192422e-20
9.95763361870797e-19
a1, same, change
"2.532666221358055, 3, 1"
k
9.682745171202744e-19
-1.1615989728684114e-20
-3.3444375376042653e-20
1.3453936680642936e-20
9.366680886961906e-19
```

1e-8の結果
```
a1, same, change
"2.5126662213580564e-08, 1, 1"
K
110698.48608165896
-2820.5518398333325
-3461.6194218487144
1410.2759199167394
105826.59073989365
a1, same, change
"2.5226662213580565e-08, 2, 1"
K
103562.1339606159
-1960.302143663261
-3402.969540214143
1377.4739097105296
99576.33618644901
a1, same, change
"2.5326662213580563e-08, 3, 1"
K
96827.45171141406
-1161.5989728609013
-3344.4375375831182
1345.3936680557858
93666.80886902582
```
これより少しの値のズレは計算誤差であることがわかる．
またomega,xで大きく違う数字を取るが，
omegaの桁が一桁ずれているため結果が大きくずれてる．
どっか間違えてるかも
```
atom_massを*10したままで進めてしまったミス
omega変わらなくなった？
計算結果を表示させて確認を行う
gt_k2は変わらない
psi0が大きくずれてる．
#psi0の値比較
* vasptest
theta=1.2425836679999999e-20
x=1.3439269141784942e-12
* jindo
theta=1.242583668e-13
x= 0.1343926914174239

theta,xは桁がずれてるだけ
```


#とりあえずe-10がいけるのかテストする

bundle exec  exe/momentmethod sample_calc/teste0/ --e0test
e0test.rb
testvasp_Cu
微分式*10で２桁ずれる
距離の単位がcmだから微分でおかしくなる?
結局微分式の調整は無しで
e-10ではx/100をすることによって正しい値となることがわかった．．

#ここからプランク定数まちがっていたかも
#これを踏まえてJでいけるかチェック
bundle exec  exe/momentmethod sample_calc/testvasp_Cu_e8/ --boltztest
testvasp_Cu_e8

Jに変換してるためk, gammaともに*1e7大きい値になってる

kが単純に1e7ずれていてomegaの計算でルートを取るためxの値は大きくずれることになる
よってこれは無理．
ergからJの変換の1e-7にcmからmの変換も含まれているのが原因かも

#e-10にJを導入してみる．
bundle exec exe/momentmethodsample_calc/teste10boltz/ --e10boltz

p omega = sqrt(k*1e3/atom_mass)
が必要．．．
これがどこから来るのかは考え無いといけない
1e-8に合わすなら*1e4すればよいため　１０で割っている要素が気になる．
質量で単位変換が必要なのかも．．．
1erg=10**-7J
erg=dyn/cm
J=N/m
dyn=g.cm/s**2
kg.m/s**2

質量を考慮すると上手くJで実装することができた．

#　fitting
Cuのvaspfittingをそのまま従来のkの計算に代入するとa2の値で大きな差異が出て負の値を取ってしまう

kの比較1-4項とその和
```
"fitting"
-3.108205879520055e-09
-24.74030058668219
-2030.538567312386
-383.4050622873846
-1844.5448315416404
"origin"
110.69848608236298
-2.8205518398516927
-3.4616194218706235
1.4102759199256707
105.82659074056633
```

vaspの計算は原子を配置を考慮しているため，従来のkの式を無視して実装してみる．
とりあえず，kだけ実装はいけた

```
-10
2.520773221358052 10   
-10
3.564911676 10   
590.217775
-20.58015873
-128.0456612
-93.42949034
348.1624648
104.8815193
-2.118305310
-3.414065486
1.383627661
100.7327762
295.1088868
```

# memo
もともとの方はy0は徐々に伸びてる

# Cuのデータ計算精度あげてみる
データをmapleに読み込めるプログラムを作った
/Users/sakaki/Research/momentmethod/vasp/MM/Cu/unit_lattice_accurate/test.rb

# k,gamma,y0をプロットしてみる．
fitting_test.rb内にk,gamma,y0をプロットするメソッドを作成する．

# 修士論文
phonopyの計算精度による比較を行う
maple fitting2に精度の高いCuのフィッティングを行う.
fittingでは精度の低いものを張っている．
fitting_test.rbは現状元素の変更をPOTCARファイルで行うだけでなく，includeを変えないといけない．
Ag,AuPOTCAR違ったので投げなおし
medeaAu_104の計算し直し
medea Alの計算
phonopy Alの精度比較

bundle exec  exe/momentmethod --fittingtest
vaspfittingの実行コマンド，includeを変える必要がある
